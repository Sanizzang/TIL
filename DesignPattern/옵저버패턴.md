### 1. 옵저버 패턴?

Observer는 '관측자' 혹은 '감시자' 라는 뜻이다. 말 그대로 감시하는 역할을 한다는 뜻이다.

Observer 패턴이라고 한다면 어떤 '이벤트'가 일어나는 것을 감시하는 패턴을 의미한다.

안드로이드를 예로 들어 설명하자면 아래와 같은 것들이 이벤트가 발생한 순간이라고 할 수 있다.

1. 사용자가 키보드를 눌렀을 때
2. 사용자가 어떤 버튼을 터치했을 때
3. 호출한 API의 응답 데이터가 수신됐을 때

정리하자면, 아무도 함수로 직접 요청한 적 없지만 시스템에 의해 발생하는 동작들을 이벤트라고 한다.

이러한 이벤트들을 감시하여, 이벤트가 발생할 때마다 미리 정의해둔 어떠한 동작을 즉각 수행하게 해주는 프로그래밍 패턴을 옵저버 패턴이라고 한다.
ex) A라는 버튼이 클릭될 때마다 화면에 '안년'을 출력하는 동작

옵저버 패턴을 활용하면 다른 객체의 상태 변화를 별도의 함수 호출 없이 즉각적으로 알 수 있기 때문에, 이벤트에 대한 처리를 자주 해야 하는 프로그램이라면 매우 효율적인 프로그램을 작성할 수 있다.

### 2. 옵저버 패턴의 구현 원리

"이벤트를 발생하는 클래스 B:가 있고, 이 "B클래스가 발생하는 이벤트를 수신받고 싶어하는 클래스 A가 있는 상황을 가정해보자.

먼저 클래스 A에서 B의 이벤트를 수신받기 위해 클래스 B를 인스턴스화 한뒤, B가 자신에게 이벤트가 발생할 때마다 클래스 A가 갖고 있는 메소드를 호출하도록 시키는 것이다.

사실 이는 치명적인 문제가 있는 구조이다.

클래스 B는 이벤트를 정상적으로 발생하고 있지만, A가 B를 일방적으로 인스턴스화 한 상황이기 때문에, B가 자신을 인스턴스화 한 대상에게 접근을 할 방법이 전혀 없다는 점이다.

그럼 어떻게 옵저버 패턴을 구현할 수 있을까?
해답은 '인터페이스'를 이용하는 것이다.

A는 인터페이스를 상속하여 이벤트가 발생할 때마다 실행되게 할 메소드를 구현해둔다. 그리고 B를 생성할 때 인터페이스 구현제츨 전달하여, 그리고 B를 생성할 때 인터페이스 구현체를 전달하여, 이벤트가 발생할 때마다 생성자로 전달받은 A가 구현한 인터페이스 메소드를 호출하면 된다.

이때, 이 인터페이스를 "Observer(옵저버)"라고 부른다.
그리고 B가 구현된 인터페이스 메소드를 호출함으로써 "이벤트를 전달하는 행위를 Callback(콜백)"이라고 한다.

### 옵저버 패턴 구현해보기

1. 1부터 100까지 하나씩 세면서 5의 배수를 만날 때마다 이벤트를 발생
2. 5의 배수 이벤트를 관찰하고 있다가 이벤트가 수신될 때마다 그 5의 배수를 출력

#### 리스터 인터페이스

우선, 이벤트를 수신받는 녀석과 이벤트를 발생하는 녀석을 이어줄 리스너를 만들어준다.

```Kotlin
interface EventListener{
    fun onEvent(count: Int)
}
```

#### 숫자 세면서 5의 배수 이벤트를 발생하는 녀석 만들기

이때, 생성자로 '리스너'를 받게 된다. 이벤트 발생 시 마다 전달받은 리스너의 메소드를 호출해줄 것이다.

```Kotlin
class Counter(var listener: EventListener) { // 생성자로 EventListener 넘겨 받음
    fun count() {
        for (i in 1..100) {
            if (i % 5 == 0) {
                listener.onEvent(i)
            }
        }
    }
}
```

#### 이벤트를 수신하는 녀석 만들기

EventListener를 상속받아, onEvent()메소드를 구현해준다. 이렇게 되면, start()가 호출되었을 때 자신이 구현한 EventListenr 구현부가 Counter()의 생성자로 전달되고, 5의 배수가 발생할 때마다 print("${count}-)가 실행되어 화면에 5의 배수가 연이어 출력되게 된다!
