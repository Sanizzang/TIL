| 구분                                                                                   | 설명                                                                                                                                                                                                                                      |
| -------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 미스테리한 이름 </br>(Mysterious name)                                                 | - 함수, 모듈, 변수, 클래스의 이름이 명백하지 않음</br>- 명명의 중요성 강조                                                                                                                                                                |
| 중복된 코드</br>(Duplicated Code)                                                      | 같은 클래스의 두 메소드에서 동일한 표현이 나타나는 경우                                                                                                                                                                                   |
| 긴 함수</br>Long Function                                                              | - 함수가 너무 길면 이해하고 유지보수하기 어려움</br>- 설명하는 주석이 붙은 코드 블록은 함수로 바꿈                                                                                                                                        |
| 전역 데이터</br>(Global Data)                                                          | - 어떤 코드에서도 글로벌 데이터가 변경이 될 수 있고 코드의</br> 어떤 부분이 그것을 조작했는지 알 수 있는 메커니즘 없음</br>- 글로벌 데이터의 형태는 글로벌 변수이고 클래스 변수와 싱글톤</br>에서도 이런 문제 발생                        |
| 변경 가능한 데이터</br>(Mutable Data)                                                  | - 데이터에 대한 변경이 예상치 못한 결과와 까다로운 버그를 유도할 수 있음</br> - 데이터를 업데이트할 때 소프트웨어의 다른 부분이 다른 상황를 요구하기</br> 때문에 실패할 가능성이 있고, 특히 아주 드문 조건에서 발생하면 오류를 찾기 힘듬. |
| 확산적 변경</br>(Divergent Change)                                                     | - 한 모듈이 여러 가지 이유로, 여러 방법으로 변경되는 경우에 발생</br>예: "새로운 DB를 추가할 때마다 항상 이 세 개의 메소드를 수정</br>해야 하는군"                                                                                        |
| 산탄총 수술</br>(Shotgun Surgery)                                                      | - 확산적 변경(Divergent Change)과 정 반대</br>- 변경을 할 때마다 많은 클래스를 조금씩 수정해야 하는 증상</br>- 병경이 여러 군데서 발생하면 찾기도 어렵고 중요한 변경을 놓치기 쉬움                                                        |
| 기능에 대한 부러움</br>(Feature Envy)                                                  | - 어떤 값을 계산하기 위해 다른 객체에 있는 여러 개의 기능</br>을 요구하는 경우                                                                                                                                                            |
| 데이터 덩어리</br>(Data Clumps)                                                        | - 데이터 항목들은 몇몇 클래스에 필드로서, 많은 메소드 서명에서 파라메</br>터로서 함께 있는 것을 보게 됨. 함께 있는 데이터는 함께하는 장소를 찾아</br>야 함.                                                                               |
| 기본 타입에 대한 강박증</br>(Primitive Obsession)                                      | - 많은 프로그래밍 언어에서 정수, 실수와 문자열 같은 기본 타입을 많이</br>사용하고 필요한 경우 money, coordinates, ranges를 만들어서 사용함.</br>- 돈 계산에서 단위를 무시하거나 전화번호를 단순히 문자열로 처리함.                        |
| 반복되는 Switch문</br>(Repeated Switches)                                              | - switch 문은 본질적으로 중복된다는 점</br>- switch 문제의 일반적 해결책은 다형성(polymorphism)                                                                                                                                           |
| 반복문</br>(Loops)                                                                     | - 프로그래밍의 핵심이었지만 종종 무시되었음                                                                                                                                                                                               |
| 게으른 요소</br>(Lazy Element)                                                         | - 프로그램 요소가 필요 없는 경우 이를 삭제                                                                                                                                                                                                |
| 추측성 일반화</br>(Speculative Generality)                                             | - 필요 하지 않은 모든 종류의 경우를 처리하고자 하는 경우                                                                                                                                                                                  |
| 임시 필드</br>(Temporary Field)                                                        | - 인스턴스 변수가 어떤 상황에서만 필요한 경우</br> - 임시 필드의 대표적인 사례는 복잡한 알고리즘에서 여러 변수가</br>사용되는 경우임. 그 필드는 그 알고리즘에서만 사용되고 다른 상</br>황에서는 혼란을 초래                               |
| 메시지 체인</br>(Message Chanins)                                                      | - 클라이언트가 어떤 객체를 얻기 위해 다른 객체에 물어보고,</br>다른 객체는 또 다른 객체에 물어보는 경우</br>(클라이언트가 내비게이션 구조와 밀접하게 연관된 경우)                                                                         |
| 미들 맨</br>(Middle Man)                                                               | - 객체의 특징은 캡슐화와 위임(delegation)</br>- 메소드의 절반이상이 하는 일이 다른 객체에게 위임하는 경우                                                                                                                                 |
| 내부 거래</br>(Insider Trading)                                                        | - 모듈 사이의 명확한 경계를 원하지만, 일이 이루어지기 위해서는</br>모듈사이의 거래가 발생하게 되고 이것을 최소한으로 할 필요가 있음                                                                                                       |
| 거대한 클래스</br>(Large Class)                                                        | - 클래스가 많은 일을 하고 있는 경우 너무 많은 필드를 갖게 되고</br>따라서 중복된 코드가 존재할 확률이 높음.                                                                                                                               |
| 다른 인터페이스를 가진 대체 클래스</br>(Alternative Classes with Different Interfaces) | - 같은 작업을 하지만 다른 메소드 시그니쳐(signature)를 가지는 경우                                                                                                                                                                        |
| 데이터 클래스</br>(Data Class)                                                         | - 필드들과 필드에 대한 getter와 setter 메소드만 가지는 클래스</br>- 이러한 클래스는 dumb data holders이고 다른 클래스에 의해</br>상세히 다루어 짐.                                                                                        |
| 거부된 유산</br>(Refused Bequest)                                                      | - 자식클래스가 부모클래스로 부터 상속받은 것을 원치 않거나 필요하지</br>않을 경우: 클래스 상속 구조가 잘못되었음을 나타냄                                                                                                                 |
| 주석</br>(Comments)                                                                    | - 주석이 코드 주위에 많이 작성되어 있을 때                                                                                                                                                                                                |
