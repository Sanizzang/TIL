## OSI 7계층

: 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것

### OSI 7단계로 정의한 이유?

통신이 일어나는 과정을 단계별로 파악하기 위함과 통신 과정 중에 특정한 곳에 이상이 생길 경우에 "다른 단계의 장비 및 소프트웨어 등을 건드리지 않고 통신 장애를 일으킨 단계에서 해결"할 수 있기 때문
![](https://velog.velcdn.com/images/sanizzang00/post/8aea29aa-c69d-4ea6-9104-ac5d34d91b10/image.png)

### OSI 7계층 단계별 역할

#### 1계층 물리 계층(Physical Layer)

실제 장치를 연결하기 위한 “전기적 및 물리적 세부 사항”을 정의한 계층
인터넷 케이블, 라우터 스위치 등의 전기적 신호가 물리적인 장치에 의해 왔다 갔다(통신)하는 계층이다. 이 계층에서는 “단지 데이터를 전달만 할 뿐” 전송하려는(또는 받으려는) 데이터가 무엇인지, 어떤 에러가 있는지 등에는 전혀 신경 쓰지 않고 단지 “데이터 전기적인 신호로 변환해서 주고받는 기능만 할 뿐”이다.
ex) 케이블 종류, 무선 주파수 링크, 핀 배치, 전압, 물리 요건 등
-> 케이블, 리피터, 허브를 통해 데이터 전송한다.

#### 2계층 데이터 링크 계층(Data Link Layer)

해당 계층은 장치 간 신호를 전달하는 물리계층을 이용하여 “네트워크 상의 주변 장치들 간의 데이터를 전송하는 역할“을 한다.
쉽게 말해 물리계층을 통해 송수신되는 “정보의 오류와 흐름을 관리“하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할을 하는 것이다.
따라서 통신에서의 오류도 찾아주고 재전송도 하는 기능을 가지고 있고 이 계층에서는 “맥 주소(Mac Address)”를 가지고 통신하게 된다.
두 지점(장치) 간의 신뢰성 있는 전송을 보장하기 위한 계층이다.
데이터 링크 계층에서 전송되는 단위를 “프레임“이라고 하고, 대표적인 장비로는 브리지, 스위치 등이 있다.

- 주소 할당: 물리 계층으로부터 받은 신호들이 네트워크 상의 장치에 올바르게 안착할 수 있게 한다.
- 오류 감지: 신호가 전달되는 동안 오류가 포함되는지 감지 오류가 있다면 해당 데이터를 폐기

-> 브릿지나 스위치를 통해 맥주소를 가지고 물리계층에서 받은 정보를 전달함.
프레임에 주소부여(MAC – 물리적주소), 에러검출/재전송/흐름제어

#### 3계층 네트워크 계층(Network Layer)

이 계층에서 가장 중요한 기능은 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)이다.
여기에 사용되는 프로토콜의 종류도 다양하고, 라우팅하는 기술도 다양하다.

이 계층은 경로를 선택하고 주소를 정하고 경로에 따라 패킷을 전달해주는 것이 이 계층의 역할이다.
이 계층의 대표적인 장비는 라우터 이며, 요즘은 2계층의 장비 중 스위치라는 장비에 라우팅 기능을 장착한 Layer 3 스위치도 있다.
(여기서 IP주소를 사용한다.)

네트워크 계층(Network layer)은 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층으로

다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)을 제공하기 위한 기능적, 절차적 수단을 제공한다.

네트워크 계층은 라우팅, 흐름 제어, 세그멘테이션(segmentation/desegmentation), 오류 제어, 인터네트워킹(Internetworking) 등을 수행한다.
라우터가 이 계층에서 동작하고 이 계층에서 동작하는 스위치도 있다.
데이터를 연결하는 다른 네트워크를 통해 전달함으로써 인터넷이 가능하게 만드는 계층이다.
논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적(hierarchical)이다.

### 2계층 데이터 링크 계층

하나의 네트워크 대역 즉, 같은 네트워크 상에 존재하는 여러 장비들 중에서 "어떤 장비가 어떤 장비에게 보내는 데이터를 전달", 추가적으로 오류제어, 흐름제어 수행
2계층은 하나의 네트워크 대역(LAN)에서만 통신할 때 사용한다. 다른 네트워크와 통신할 때는 항상 3계층이 도와주어야 한다. 3계층의 주소와 3계층의 프로토콜을 이용하여야만 다른 네트워크와 통신이 가능하다.

![](https://velog.velcdn.com/images/sanizzang00/post/28583579-9c92-41e1-9ddc-5c292975cd74/image.png)
-> 12개의 16진수로 이루어져 있음
: MAC 주소 = 6byte (16진수 2개당 1byte)

![](https://velog.velcdn.com/images/sanizzang00/post/f3241eb3-35f3-49d8-b43d-7eec75a52069/image.png)

- Preamble: 동기화에 사용되는 64비트 필드 (8byte)

- Destination Address (6byte)
  : 목적지 MAC 주소

- Source Address (6byte)
  : 송신지 MAC 주소

- Ethernet Type (2byte)
  : 상위 프로토콜을 알려줌 (분석을 위해)
  상위 프로토콜 타입: IPv4(0x0800), ARP(0x0806)

- DATA: 상위 레이어의 프로토콜에 의해 사용되는 정보

### 3계층: 네트워크 계층

: 다른 네트워크 대역 즉, "멀리 떨어진 곳에 존재하는 네트워크까지 어떻게 데이터를 전달할지 제어하는 일"을 담당, 발신에서 착신까지의 패킷의 경로를 제어
WAN에서 통실할 때 사용하는 “IP주소”

![](https://velog.velcdn.com/images/sanizzang00/post/5a40f660-269c-4600-8ef8-0dd763342f05/image.png)

![](https://velog.velcdn.com/images/sanizzang00/post/032d20d4-d647-4208-aaf4-0339b77a4f1a/image.png)

- Version (4bit)
  : IP 프로토콜의 버전 (무조건 4가 옴)
  -> IPv6는 프로토콜 구조 자체가 다름

- Header Length (4bit)
  : 헤더길이 최소 20byte ~ 60byte 4bit는 십진수 15까지 -> 나누기 4로 나타냄

- Type-of-Service Flags (8bit)
  : 서비스의 우선순위 제공 (사용하지 않음)

- Total Length (16bit)
  : 뒤에 페이로드까지 합쳐진 길이 상위계층에서부터 encapsulation해서 내려온 길이랑 전부 다 합친 전체의 길이

- identification 필드 (8bit)
  : 데이터가 큰 걸 보낼 때 최대전송길이가 있어서 잘게 잘라서 보낸다. 그때 사용되는 값. 쪼개진 애들을 알아볼 수 있게 해줌. 원래의 데이터 식별

- IP Flags (3bit)
  : 패킷의 분할 여부에 대한 정보를 나타내는 3비트 영역.
  D(Don’t Fragmentation): 패킷을 보내는 사람이 데이터를 안쪽에서 보내겠다.
  M(More Fragmentation): 원래 데이터의 분열된 조각이 더 있는지 여부 판단.

- Fragmentation Offset (13bit)
  : 분할된 패킷을 재조립할 수 있도록 원래 위치를 알려주는 영역으로, 바이트를 8로 나눈 값을 사용한다.

- Time-to-live (8bit)
  : 데이터를 전달할 수 없는 것으로 판단되어 이전에 데이터가 이동할 수 있는 단계의 수 (운영체제 마다 TTL 값이 다르다. 리눅스: 64, 윈도우: 128)

- Protocol Identifier (8bit)
  : 상위 계층 프로토콜
  1 ICMP / 2 IGMP / 6 TCP / 17 UDP

- Header Checksum (16bit)
  : IP 헤더의 체크섬을 저장, 라우터를 지나갈때 마다 재 계산을 하기 때문에 속도가 떨어진다.

- Source IP Address (32bit)
  : 출발지 IP 주소

- Destination IP Address (32bit)
  : 목적지 IP 주소

- Options
  : 특별한 처리 옵션

#### 서브넷 마스크

: Classful한 네트워크 대역을 나눠주는데 사용하는 값
어디까지나 네트워크 대역을 구분하는데 사용하고 어디서부터 호스트를 구분하는데 사용하는지 지정,
2진수로 표기했을 때 1로시작, 1과 1사이에는 0이 올 수 없다는 규칙을 가지고 있다.

#### 사설IP와 공인 IP

공인IP 1개당 2^32개의 사설IP

#### NAT

특정 IP를 특정 IP로 바꾸는 것

#### 특수한 IP 주소

- Wildcard
  0.0.0.0
  : 나머지 모든 IP

- 나 자신을 나타내는 주소
  127.0.0.1

- 어딘가로 가려면 일단 여기로
  게이트웨이 주소

#### ARP 프로토콜 (28byte)

: 같은 네트워크 대역에서 통신을 하기 위해 필요한 MAC주소를 IP주소를 이용해서 알아오는 프로토콜이다.

같은 네트워크 대역에서 통신을 한다고 하더라고 데이터를 보내기 위해서는 7계층부터 캡슐화를 통해 데이터를 보내기 때문에 IP주소와 MAC주소가 모두 필요하다. 이 때 IP주소는 알고 MAC주소는 모르더라도 ARP를 통해 통신이 가능하다.

#### ICMP 프로토콜 (8byte)

네트워크 컴퓨터 위에서 돌아가는 운영체제에서 오류 메시지를 전송 받는 데 주로 쓰인다. 프로토콜 구조의 Type과 Code를 통해 오류 메시지를 전송 받는다.

#### IPv4의 조각화

큰 IP 패킷들이 적은 MTU(Maximum Transmission Unit)를 갖는 링크를 통하여 전송되려면 여러 개의 작은 패킷으로 쪼개어/조각화 되어 전송돼야 한다.

즉, 목적지까지 패킷을 전달하는 과정에 통과하는 각 라우터마다 전송에 적합한 프레임으로 변환이 필요하다.

일단 조각화되면, 최종 목적지에 도달할 때까지 재조립되지 않는 것이 일반적이다.

IPv4에서는 발신지 뿐만 아니라 중간 라우터에서도 IP 조각화가 가능
IPv6에서는 IP 단편화가 발신지에서 만 가능
재조립은 항상 최종 수신지에서 만 가능함

IPv4의 조각화란?
-> 여러 개의 패킷으로 조각화 된 패킷
![](https://velog.velcdn.com/images/sanizzang00/post/636b3085-ba7e-4bd5-a82d-eed156ce4e07/image.png)
MTU: 3,300-Byte (보통 MTU는 1500)
보통 IPv4헤더의 크기: 20-Byte
순수하게 보낼 수 있는 페이로드같은 경우는 3,280 byte
Offset: 첫 번째 데이터 크기만큼 떨어져 있음(8로 나눠서 표기)

### 4계층: 전송계층

: 송신자의 프로세스와 수신자의 프로세스를 연결하는 통신 서비스를 제공
전송 계층은 연결 지향 데이터 스트림 지원, 신뢰성, 흐름 제어, 그리고 다중화와 같은
편리한 서비스 제공
전송 프로토콜 중 가장 잘 알려진 것은 연결 지향 전송 방식을 사용하는 전송 제어 프로토콜(TCP)이다. 보다 단순한 전송에 사용되는 사용자 데이터그램 프로토콜(UDP)도 있다.

#### 포트 번호

특정 프로세스와 특정 프로세스가 통신을 하기 위해 사용.
하나의 포트는 하나의 프로세스만 사용 가능.
하나의 프로세스가 여러 개의 포트를 사용하는 것은 가능.
포트 번호는 일반적으로 정해져 있지만 무조건 지켜야 하는 것은 아니다.

![](https://velog.velcdn.com/images/sanizzang00/post/187ebfd9-8322-4796-b8bc-d839f9529387/image.png)
![](https://velog.velcdn.com/images/sanizzang00/post/9cbbed16-3dcf-4b68-82e8-3713b43031a6/image.png)
![](https://velog.velcdn.com/images/sanizzang00/post/47b18a60-d0f9-4b94-8421-ae5773f7ebd7/image.png)

#### UDP 프로토콜 (8byte)

: UDP의 전송방식은 너무 단순해서 서비스의 신뢰성이 낮고, 데이터그램 도착 순서가 바뀌거나, 중복되거나, 심지어는 통보 없이 누락시키기도 한다. UDP는 일반적으로 오류의 검사와 수정이 필요 없는 프로그램에서 수행할 것으로 가정한다.
![](https://velog.velcdn.com/images/sanizzang00/post/25a86d28-b457-45b5-928d-cce96c15168b/image.png)

- Source Port(2byte)
  : 출발지 포트번호

- Destination Port(2byte)
  : 목적지 포트번호

- Length(2byte)
  : 페이로드까지 합한 길이

- Checksum(2byte)
  : 헤더 오류 검증

UDP프로토콜을 사용하는 프로그램:

1. 도메인을 물으면 IP를 알려주는 DNS 서버
2. 라우팅 정보를 공유하는 RIP 프로토콜

#### TCP 프로토콜 (20byte)

: 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 통신을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다.
TCP의 안정성을 필요로 하지 않는 애플리케이션의 경우 일반적으로 TCP 대신 비접속형 사용자 데이터그램 프로토콜을 사용한다.
TCP는 UDP보다 안전하지만 느리다.
![](https://velog.velcdn.com/images/sanizzang00/post/784dac4d-e5e0-49ac-bc47-115feb8c03cd/image.png)

- Source Port address (16bit)
  : 데이터를 생성한 애플리케이션에서 사용하는 포트번호를 나타냄

- Destination Port address (16bit)
  : 목적지 애플리케이션이 사용하는 포트 번호

- Sequence number (32bit)
  : - 전송되는 데이터의 가상 회선을 통해 전송되는 데이터의 모든 바이트에는 고유한 일련 번호가 부여
- 네트워크가 불안하여 패킷을 분실, 지연 등으로 세그먼트의 순서가 어긋나게 도착할 수 있기 때문에
  sequence number를 이용하여 데이터를 올바른 순서로 재배열할 수 있다.

- Acknowledgement number 필드(32bit)
  : - 다음 세그먼트를 수신할 준비가 되었다는 사실을 알린다.

  - 모든 데이터가 수신되었다는 것을 나타내는 묵시적인 확인 메시지 역할

- Offset
  : 헤더의 길이

- Reserved
  : 예약된 필드

- TCP Flags
  U: Urgent Flag 긴급 비트
  A: Acknowledge Flag 승인 비트, 확인 응답 메시지
  P: Push Flag 밀어 넣기 비트, 데이터를 포함한다는 것을 뜻한다.
  R: Reset Flag 초기화 비트, 수신 거부를 하고자 할때 사용
  S: Synchronized Flag 동기화 비트 상대방과 연결을 시작할 때 무조건 사용하는 플래그
  F: FIN Flag 종료 비트, 작업이 끝나고 가상 회선을 종결하고자 할 때 사용

- Window
  : 남아있는 TCP 버퍼 공간

- Checksum
  : 오류 체크

- Urgent Pointer
  : 어디부터가 긴급비트다.

#### TCP를 이용한 통신 과정

TCP를 이용한 데이터 통신을 할 때 프로세스와 프로세스를 연결하기 위해 가장 먼저 수행되는 과정

1. 클라이언트가 서버에게 요청 패킷을 보내고
2. 서버가 클라이언트의 요청을 받아들이는 패킷을 보내고
3. 클라이언트는 이를 최종적으로 수락하는 패킷을 보낸다.
   위의 3개의 과정을 3Way Handshake라고 부른다.

#### DNS

: 도메인 이름과 IP주소를 매핑시켜주는 거대한 분산시스템
query를 보내고 response를 받는다.
![](https://velog.velcdn.com/images/sanizzang00/post/5a7a3525-f37a-4646-82f6-75d501baa16a/image.png)

Name Server를 아는법?

- 자동으로 DNS 주소를 넣어주는 프로토콜: "DHCP" 프로토콜

DHCP 주소를 알려주는 것은?
: BroadCast(255.255.255.255)를 통해 주변에 DHCP 서버가 있는지 물어본다.
(내 IP와 DHCP 주소를 모르기 때문)
-> DHCP를 찾으면 IP주소와 Name Server를 준다.

### RFC

#### RFC 868: Time Protocol

- time protocol은 시간에 대해서 “숫자 하나”로 준다.
- 시간을 나타내기 위해 integer값 하나로 시간을 나타낸다.
- 1900년 1월 1일부터 원하는 시간을 “초”로 나타낸다.
- 1900년 이전 시간은 음수로 표현
- TCP, UDP 둘 다 사용 가능
- 포트는 37번 포트를 사용
- 32bit 이진수로 시간을 전송
- 이 서비스는 2034년까지 사용가능하다.(32bit의 한계)

#### RFC 867: Daytime Protocol

- 디버깅과 측정에 유용한 도구
- 입력값과 상관없이 단순히 현재 날짜와 시간을 문자열로 전송.
- 13번 포트 사용
